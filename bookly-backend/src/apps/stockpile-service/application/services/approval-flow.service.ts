import { Injectable, Inject, NotFoundException } from '@nestjs/common';
import { LoggingService } from '@libs/logging/logging.service';
import { ApprovalFlowRepository } from '@apps/stockpile-service/domain/repositories/approval-flow.repository';
import { ApprovalFlowEntity, ApprovalLevelEntity, ApprovalRequestEntity } from '@apps/stockpile-service/domain/entities/approval-flow.entity';
import {
  CreateApprovalFlowDto,
  UpdateApprovalFlowDto,
  CreateApprovalLevelDto,
  ProcessApprovalRequestDto,
  SubmitReservationForApprovalDto,
  CancelReservationDto,
  GetApprovalFlowsDto,
  GetPendingApprovalRequestsDto,
  ApprovalFlowDto,
  ApprovalLevelDto,
  ApprovalRequestDto
} from '@libs/dto/stockpile/approval-flow.dto';
import { LoggingHelper } from '@libs/logging/logging.helper';
import { StockpileHandlerUtil } from '@apps/stockpile-service/application/utils/stockpile-handler.util';

@Injectable()
export class ApprovalFlowService {
  constructor(
    @Inject('ApprovalFlowRepository') private readonly approvalFlowRepository: ApprovalFlowRepository,
    private readonly loggingService: LoggingService
  ) {}

  async createApprovalFlow(dto: CreateApprovalFlowDto): Promise<ApprovalFlowDto> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Creating approval flow', 'ApprovalFlowService', dto);

    // Business logic: Create new approval flow
    const flowEntity = new ApprovalFlowEntity(
      '', // id will be generated by repository
      dto.name,
      'system', // createdBy - should come from user context
      dto.description,
      dto.programId,
      dto.resourceType,
      dto.categoryId,
      dto.isDefault || false,
      dto.requiresAllApprovals ?? true,
      dto.autoApprovalEnabled || false,
      dto.reviewTimeHours,
      undefined, // reminderHours
      true, // isActive
      new Date(), // createdAt
      new Date()  // updatedAt
    );

    const savedFlow = await this.approvalFlowRepository.createApprovalFlow(flowEntity);
    return this.toApprovalFlowDto(savedFlow);
  }

  async updateApprovalFlow(id: string, dto: UpdateApprovalFlowDto): Promise<ApprovalFlowDto> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Updating approval flow', 'ApprovalFlowService', { id, ...dto });

    // Business logic: Validate and update existing flow
    const existingFlow = await this.approvalFlowRepository.findApprovalFlowById(id);
    if (!existingFlow) {
      throw new NotFoundException('Approval flow not found');
    }

    // Create update payload (entities are immutable)
    const updates: any = {};
    if (dto.name !== undefined) updates.name = dto.name;
    if (dto.description !== undefined) updates.description = dto.description;

    const updatedFlow = await this.approvalFlowRepository.updateApprovalFlow(id, updates);
    return this.toApprovalFlowDto(updatedFlow);
  }

  async createApprovalLevel(dto: CreateApprovalLevelDto): Promise<ApprovalLevelDto> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Creating approval level', 'ApprovalFlowService', dto);

    // Business logic: Create new approval level
    const levelEntity = new ApprovalLevelEntity(
      '', // id will be generated by repository
      dto.flowId,
      dto.level,
      dto.name,
      dto.description,
      dto.approverRoles || [],
      dto.approverUsers || [],
      false, // requiresAll - default to false
      dto.timeoutHours,
      true, // isActive
      new Date(), // createdAt
      new Date()  // updatedAt
    );

    const savedLevel = await this.approvalFlowRepository.createApprovalLevel(levelEntity);
    return this.toApprovalLevelDto(savedLevel);
  }

  async submitReservationForApproval(dto: SubmitReservationForApprovalDto): Promise<void> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Submitting reservation for approval', 'ApprovalFlowService', dto);

    // Business logic: Find appropriate approval flow and create requests
    const approvalFlow = await this.findApprovalFlowForReservation(
      dto.programId,
      dto.resourceType,
      dto.categoryId
    );

    if (!approvalFlow) {
      throw new NotFoundException('No approval flow configured for this reservation type');
    }

    const levels = await this.approvalFlowRepository.findApprovalLevelsByFlowId(approvalFlow.id);
    
    // Create approval requests for each level
    for (const level of levels.filter(l => l.isActive)) {
      const requestEntity = new ApprovalRequestEntity(
        '', // id will be generated by repository
        dto.reservationId,
        level.id,
        'PENDING' as any, // status
        undefined, // approverId
        undefined, // comments
        new Date(), // requestedAt
        undefined, // respondedAt
        level.timeoutHours ? new Date(Date.now() + level.timeoutHours * 60 * 60 * 1000) : undefined, // timeoutAt
        {}, // notificationsSent
        new Date(), // createdAt
        new Date()  // updatedAt
      );

      await this.approvalFlowRepository.createApprovalRequest(requestEntity);
    }

    this.loggingService.log('Reservation submitted for approval successfully', 'ApprovalFlowService');
  }

  async processApprovalRequest(requestId: string, dto: { approverId: string; action: string; comments?: string }): Promise<void> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Processing approval request', 'ApprovalFlowService', { requestId, ...dto });

    // Business logic: Process approval/rejection
    const request = await this.approvalFlowRepository.findApprovalRequestById(requestId);
    if (!request) {
      throw new NotFoundException('Approval request not found');
    }

    if (request.status !== 'PENDING') {
      throw new Error('Request has already been processed');
    }

    // Create updated request using entity methods
    let updatedRequest: ApprovalRequestEntity;
    if (dto.action.toUpperCase() === 'APPROVED') {
      updatedRequest = request.approve(dto.approverId, dto.comments);
    } else {
      updatedRequest = request.reject(dto.approverId, dto.comments);
    }

    await this.approvalFlowRepository.updateApprovalRequest(requestId, {
      status: updatedRequest.status,
      approverId: updatedRequest.approverId,
      comments: updatedRequest.comments,
      respondedAt: updatedRequest.respondedAt,
      updatedAt: new Date()
    });

    // Check if reservation approval is complete
    await this.checkReservationApprovalCompletion(request.reservationId);
  }

  async cancelReservation(dto: CancelReservationDto): Promise<void> {
    StockpileHandlerUtil.logServiceOperation(this.loggingService, 'Canceling reservation', 'ApprovalFlowService', dto);

    // Business logic: Cancel all pending approval requests
    const requests = await this.approvalFlowRepository.findApprovalRequestsByReservationId(dto.reservationId);
    
    for (const request of requests.filter(r => r.status === 'PENDING')) {
      await this.approvalFlowRepository.updateApprovalRequest(request.id, {
        status: 'CANCELLED' as any,
        comments: dto.reason || 'Reservation cancelled',
        respondedAt: new Date(),
        updatedAt: new Date()
      });
    }

    this.loggingService.log('Reservation approval requests cancelled', 'ApprovalFlowService');
  }

  async getApprovalFlows(dto: GetApprovalFlowsDto): Promise<ApprovalFlowDto[]> {
    const flows = await this.approvalFlowRepository.findApprovalFlowsByScope(
      dto.programId,
      dto.resourceType,
      dto.categoryId
    );

    // Apply filters
    let filteredFlows = flows;
    if (dto.isActive !== undefined) {
      filteredFlows = filteredFlows.filter(flow => flow.isActive === dto.isActive);
    }

    return filteredFlows.map(flow => this.toApprovalFlowDto(flow));
  }

  async getApprovalFlowById(id: string): Promise<ApprovalFlowDto | null> {
    const flow = await this.approvalFlowRepository.findApprovalFlowById(id);
    return flow ? this.toApprovalFlowDto(flow) : null;
  }

  async getDefaultApprovalFlow(
    programId?: string,
    resourceType?: string,
    categoryId?: string
  ): Promise<ApprovalFlowDto | null> {
    const flow = await this.approvalFlowRepository.findDefaultApprovalFlow(
      programId,
      resourceType,
      categoryId
    );
    return flow ? this.toApprovalFlowDto(flow) : null;
  }

  async getApprovalLevelsByFlowId(flowId: string): Promise<ApprovalLevelDto[]> {
    const levels = await this.approvalFlowRepository.findApprovalLevelsByFlowId(flowId);
    return levels.map(level => this.toApprovalLevelDto(level));
  }

  async getPendingApprovalRequests(dto: GetPendingApprovalRequestsDto): Promise<{ requests: ApprovalRequestDto[]; total: number }> {
    let requests: ApprovalRequestEntity[] = [];

    if (dto.approverId) {
      requests = await this.approvalFlowRepository.findPendingApprovalRequestsByApprover(dto.approverId);
    } else {
      // For now, return empty as repository doesn't have this method
      // TODO: Implement findPendingApprovalRequests with filters in repository
      requests = [];
    }

    // Apply pagination
    const startIndex = (dto.page - 1) * dto.limit;
    const endIndex = startIndex + dto.limit;
    const paginatedRequests = requests.slice(startIndex, endIndex);

    return {
      requests: paginatedRequests.map(req => this.toApprovalRequestDto(req)),
      total: requests.length
    };
  }

  async getApprovalRequestsByReservation(reservationId: string): Promise<ApprovalRequestDto[]> {
    const requests = await this.approvalFlowRepository.findApprovalRequestsByReservationId(reservationId);
    return requests.map(req => this.toApprovalRequestDto(req));
  }

  async getReservationStatus(reservationId: string): Promise<{
    reservationId: string;
    status: string;
    currentLevel?: number;
    pendingRequests: ApprovalRequestDto[];
    completedRequests: ApprovalRequestDto[];
  }> {
    const requests = await this.approvalFlowRepository.findApprovalRequestsByReservationId(reservationId);
    
    const pendingRequests = requests.filter(req => req.status === 'PENDING');
    const completedRequests = requests.filter(req => req.status !== 'PENDING');

    // Business logic: Determine reservation status
    let status = 'INITIAL';
    let currentLevel = 0;

    if (requests.length === 0) {
      status = 'INITIAL';
    } else if (pendingRequests.length > 0) {
      status = 'REVIEWING';
      // Find current level from pending requests
      const levels = await Promise.all(
        pendingRequests.map(req => this.approvalFlowRepository.findApprovalLevelById(req.levelId))
      );
      currentLevel = Math.min(...levels.filter(l => l).map(l => l!.level));
    } else {
      // Check completion status
      const hasRejected = completedRequests.some(req => req.status === 'REJECTED');
      const hasTimeout = completedRequests.some(req => req.status === 'TIMEOUT');
      
      if (hasRejected) {
        status = 'REJECTED';
      } else if (hasTimeout) {
        status = 'TIMEOUT';
      } else {
        status = 'APPROVED';
      }
    }

    return {
      reservationId,
      status,
      currentLevel: currentLevel > 0 ? currentLevel : undefined,
      pendingRequests: pendingRequests.map(req => this.toApprovalRequestDto(req)),
      completedRequests: completedRequests.map(req => this.toApprovalRequestDto(req))
    };
  }

  async getExpiredApprovalRequests(): Promise<ApprovalRequestDto[]> {
    const expiredRequests = await this.approvalFlowRepository.findExpiredApprovalRequests();
    return expiredRequests.map(req => this.toApprovalRequestDto(req));
  }

  // ======================== PRIVATE HELPER METHODS ========================

  private async findApprovalFlowForReservation(
    programId?: string,
    resourceType?: string,
    categoryId?: string
  ): Promise<ApprovalFlowEntity | null> {
    // Try to find most specific flow first
    if (programId && resourceType && categoryId) {
      const flow = await this.approvalFlowRepository.findDefaultApprovalFlow(programId, resourceType, categoryId);
      if (flow) return flow;
    }

    // Try program + resource type
    if (programId && resourceType) {
      const flow = await this.approvalFlowRepository.findDefaultApprovalFlow(programId, resourceType);
      if (flow) return flow;
    }

    // Try resource type only
    if (resourceType) {
      const flow = await this.approvalFlowRepository.findDefaultApprovalFlow(undefined, resourceType);
      if (flow) return flow;
    }

    // Fall back to global default
    return await this.approvalFlowRepository.findDefaultApprovalFlow();
  }

  private async checkReservationApprovalCompletion(reservationId: string): Promise<void> {
    const requests = await this.approvalFlowRepository.findApprovalRequestsByReservationId(reservationId);
    
    const pendingRequests = requests.filter(req => req.status === 'PENDING');
    const rejectedRequests = requests.filter(req => req.status === 'REJECTED');

    // If any request is rejected, cancel remaining pending requests
    if (rejectedRequests.length > 0) {
      for (const pendingRequest of pendingRequests) {
        await this.approvalFlowRepository.updateApprovalRequest(pendingRequest.id, {
          status: 'CANCELLED' as any,
          comments: 'Cancelled due to rejection at earlier level',
          respondedAt: new Date(),
          updatedAt: new Date()
        });
      }
    }

    // TODO: Add logic to trigger next approval level or final approval
    // This would depend on the specific approval flow requirements
  }

  // ======================== DTO CONVERSION METHODS ========================

  private toApprovalFlowDto(entity: ApprovalFlowEntity): ApprovalFlowDto {
    return {
      id: entity.id,
      name: entity.name,
      description: entity.description,
      programId: entity.programId,
      resourceType: entity.resourceType,
      categoryId: entity.categoryId,
      isDefault: entity.isDefault,
      requiresAllApprovals: entity.requiresAllApprovals,
      autoApprovalEnabled: entity.autoApprovalEnabled,
      reviewTimeHours: entity.reviewTimeHours,
      isActive: entity.isActive,
      createdBy: entity.createdBy,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt
    };
  }

  private toApprovalLevelDto(entity: ApprovalLevelEntity): ApprovalLevelDto {
    return {
      id: entity.id,
      flowId: entity.flowId,
      level: entity.level,
      name: entity.name,
      description: entity.description,
      approverRoles: entity.approverRoles,
      approverUsers: entity.approverUsers,
      requiresAll: entity.requiresAll,
      timeoutHours: entity.timeoutHours,
      isActive: entity.isActive,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt
    };
  }

  async getApprovalHistory(dto: {
    reservationId?: string;
    approverId?: string;
    startDate?: Date;
    endDate?: Date;
    page?: number;
    limit?: number;
  }): Promise<{ actions: any[]; total: number }> {
    this.loggingService.log('Getting approval history', 'ApprovalFlowService', LoggingHelper.logParams(dto));

    // Business logic: Query approval requests and transform to history actions
    let requests: ApprovalRequestEntity[] = [];
    
    if (dto.reservationId) {
      requests = await this.approvalFlowRepository.findApprovalRequestsByReservationId(dto.reservationId);
    } else {
      // For now, return empty result for complex filtering until repository method is implemented
      return { actions: [], total: 0 };
    }

    // Transform requests to history actions
    const actions = requests
      .filter(request => {
        if (dto.approverId && request.approverId !== dto.approverId) return false;
        if (dto.startDate && request.createdAt < dto.startDate) return false;
        if (dto.endDate && request.createdAt > dto.endDate) return false;
        return true;
      })
      .map(request => ({
        id: request.id,
        reservationId: request.reservationId,
        approverId: request.approverId,
        action: request.status,
        comments: request.comments,
        timestamp: request.respondedAt || request.createdAt,
        level: request.levelId
      }));

    // Simple pagination
    const page = dto.page || 1;
    const limit = dto.limit || 10;
    const startIndex = (page - 1) * limit;
    const paginatedActions = actions.slice(startIndex, startIndex + limit);

    return {
      actions: paginatedActions,
      total: actions.length
    };
  }

  async getUserApprovalStatistics(dto: {
    userId: string;
    startDate?: Date;
    endDate?: Date;
  }): Promise<{
    userId: string;
    totalRequests: number;
    approvedRequests: number;
    rejectedRequests: number;
    pendingRequests: number;
    averageResponseTime?: number;
  }> {
    this.loggingService.log('Getting user approval statistics', 'ApprovalFlowService', LoggingHelper.logParams(dto));

    // Business logic: Calculate user statistics from existing repository methods
    const allRequests = await this.approvalFlowRepository.findPendingApprovalRequestsByApprover(dto.userId);

    // Filter by date range if provided
    const filteredRequests = allRequests.filter(request => {
      if (dto.startDate && request.createdAt < dto.startDate) return false;
      if (dto.endDate && request.createdAt > dto.endDate) return false;
      return true;
    });

    // Count by status
    const approvedCount = filteredRequests.filter(r => r.status === 'APPROVED').length;
    const rejectedCount = filteredRequests.filter(r => r.status === 'REJECTED').length;
    const pendingCount = filteredRequests.filter(r => r.status === 'PENDING').length;
    const totalCount = filteredRequests.length;

    // Calculate average response time for completed requests
    const completedRequests = filteredRequests.filter(r => r.respondedAt && r.requestedAt);
    let averageResponseTime: number | undefined;
    
    if (completedRequests.length > 0) {
      const totalResponseTime = completedRequests.reduce((sum, request) => {
        const responseTime = request.respondedAt!.getTime() - request.requestedAt.getTime();
        return sum + responseTime;
      }, 0);
      averageResponseTime = totalResponseTime / completedRequests.length / (1000 * 60 * 60); // Convert to hours
    }

    return {
      userId: dto.userId,
      totalRequests: totalCount,
      approvedRequests: approvedCount,
      rejectedRequests: rejectedCount,
      pendingRequests: pendingCount,
      averageResponseTime
    };
  }

  private toApprovalRequestDto(entity: ApprovalRequestEntity): ApprovalRequestDto {
    return {
      id: entity.id,
      reservationId: entity.reservationId,
      levelId: entity.levelId,
      approverId: entity.approverId,
      status: entity.status as string,
      comments: entity.comments,
      requestedAt: entity.requestedAt,
      respondedAt: entity.respondedAt,
      timeoutAt: entity.timeoutAt,
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt
    };
  }
}
