import { Injectable, NotFoundException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { RoleRepository } from '../../domain/repositories/role.repository';
import { PermissionRepository } from '../../domain/repositories/permission.repository';
import { Role } from '../../domain/entities/user.entity';
import { RoleEntity } from '../../domain/entities/role.entity';
import { PermissionEntity } from '../../domain/entities/permission.entity';
import { LoggingService } from '@libs/logging/logging.service';
import { LoggingHelper } from '@libs/logging/logging.helper';
import {
  CreateRoleDto,
  UpdateRoleDto,
  AssignPermissionDto,
  RoleResponseDto,
} from '../../../../libs/dto/auth/role.dto';

@Injectable()
export class RoleService {
  constructor(
    private readonly roleRepository: RoleRepository,
    private readonly permissionRepository: PermissionRepository,
    private readonly loggingService: LoggingService,
  ) {}

  async findById(id: string): Promise<RoleEntity | null> {
    try {
      const role = await this.roleRepository.findByIdWithPermissions(id);
      if (!role) {
        throw new NotFoundException(`Role with ID ${id} not found`);
      }
      return role;
    } catch (error) {
      this.loggingService.error('Failed to find role by ID', error, LoggingHelper.logParams({
        roleId: id,
      }));
      throw error;
    }
  }

  async findByName(name: string): Promise<RoleEntity | null> {
    try {
      return await this.roleRepository.findByNameWithPermissions(name);
    } catch (error) {
      this.loggingService.error('Failed to find role by name', error, LoggingHelper.logParams({
        roleName: name,
      }));
      throw error;
    }
  }

  async findAll(page = 1, limit = 10, search?: string, category?: string): Promise<{
    roles: RoleEntity[];
    total: number;
  }> {
    try {
      return await this.roleRepository.findAllWithPermissions(page, limit, search, category);
    } catch (error) {
      this.loggingService.error('Failed to find all roles', error, LoggingHelper.logParams({
        page,
        limit,
        search,
        category,
      }));
      throw error;
    }
  }

  async create(data: CreateRoleDto, createdBy: string): Promise<RoleEntity> {
    try {
      // Validate that role name is unique
      const existingRole = await this.roleRepository.findByName(data.name);
      if (existingRole) {
        throw new BadRequestException(`Role with name '${data.name}' already exists`);
      }

      // Create role entity
      const roleEntity = new RoleEntity(
        '', // ID will be generated by repository
        data.name,
        data.name.toUpperCase().replace(/\s+/g, '_'), // Generate code from name
        data.description || '',
        data.category || 'ACADEMICO', // Use category code from unified Category model
        true, // Active by default
        false, // Custom roles are not predefined
        new Date(),
        new Date(),
        createdBy, // createdBy
        [], // permissions array
        undefined, // programId - not in CreateRoleDto
        undefined, // metadata - not in CreateRoleDto
      );

      const created = await this.roleRepository.create(roleEntity);

      this.loggingService.log('Role created successfully', LoggingHelper.logParams({
        roleId: created.id,
        roleName: created.name,
        category: created.category,
        createdBy,
      }));

      return created;
    } catch (error) {
      this.loggingService.error('Failed to create role', error, LoggingHelper.logParams({
        roleName: data.name,
        category: data.category,
        createdBy,
      }));
      throw error;
    }
  }

  async update(id: string, data: UpdateRoleDto, updatedBy: string): Promise<RoleEntity> {
    try {
      const existingRole = await this.roleRepository.findById(id);
      if (!existingRole) {
        throw new NotFoundException(`Role with ID ${id} not found`);
      }

      // Prevent modification of predefined roles
      if (existingRole.isPredefined) {
        throw new ForbiddenException('Predefined roles cannot be modified');
      }

      // Validate unique name if changing
      if (data.name && data.name !== existingRole.name) {
        const roleWithSameName = await this.roleRepository.findByName(data.name);
        if (roleWithSameName) {
          throw new BadRequestException(`Role with name '${data.name}' already exists`);
        }
      }

      const updated = await this.roleRepository.update(id, data);

      this.loggingService.log('Role updated successfully', LoggingHelper.logParams({
        roleId: id,
        changes: data,
        updatedBy,
      }));

      return updated;
    } catch (error) {
      this.loggingService.error('Failed to update role', error, LoggingHelper.logParams({
        roleId: id,
        changes: data,
        updatedBy,
      }));
      throw error;
    }
  }

  async delete(id: string, deletedBy: string): Promise<void> {
    try {
      const existingRole = await this.roleRepository.findById(id);
      if (!existingRole) {
        throw new NotFoundException(`Role with ID ${id} not found`);
      }

      // Prevent deletion of predefined roles
      if (existingRole.isPredefined) {
        throw new ForbiddenException('Predefined roles cannot be deleted');
      }

      // Check if role is assigned to any users
      const usersWithRole = await this.roleRepository.findUsersWithRole(id);
      if (usersWithRole.length > 0) {
        throw new BadRequestException(
          `Cannot delete role '${existingRole.name}' as it is assigned to ${usersWithRole.length} user(s)`
        );
      }

      await this.roleRepository.delete(id);

      this.loggingService.log('Role deleted successfully', LoggingHelper.logParams({
        roleId: id,
        roleName: existingRole.name,
        deletedBy,
      }));
    } catch (error) {
      this.loggingService.error('Failed to delete role', error, LoggingHelper.logParams({
        roleId: id,
        deletedBy,
      }));
      throw error;
    }
  }

  async findActiveRoles(): Promise<RoleEntity[]> {
    try {
      return await this.roleRepository.findActiveRoles();
    } catch (error) {
      this.loggingService.error('Failed to find active roles', error);
      throw error;
    }
  }

  async findPredefinedRoles(): Promise<RoleEntity[]> {
    try {
      return await this.roleRepository.findPredefinedRoles();
    } catch (error) {
      this.loggingService.error('Failed to find predefined roles', error);
      throw error;
    }
  }

  async assignPermission(roleId: string, permissionId: string, assignedBy: string): Promise<void> {
    try {
      const role = await this.roleRepository.findById(roleId);
      if (!role) {
        throw new NotFoundException(`Role with ID ${roleId} not found`);
      }

      const permission = await this.permissionRepository.findById(permissionId);
      if (!permission) {
        throw new NotFoundException(`Permission with ID ${permissionId} not found`);
      }

      await this.roleRepository.assignPermission(roleId, permissionId);

      this.loggingService.log('Permission assigned to role successfully', LoggingHelper.logParams({
        roleId,
        roleName: role.name,
        permissionId,
        permissionName: permission.name,
        assignedBy,
      }));
    } catch (error) {
      this.loggingService.error('Failed to assign permission to role', error, LoggingHelper.logParams({
        roleId,
        permissionId,
        assignedBy,
      }));
      throw error;
    }
  }

  async removePermission(roleId: string, permissionId: string, removedBy: string): Promise<void> {
    try {
      const role = await this.roleRepository.findById(roleId);
      if (!role) {
        throw new NotFoundException(`Role with ID ${roleId} not found`);
      }

      const permission = await this.permissionRepository.findById(permissionId);
      if (!permission) {
        throw new NotFoundException(`Permission with ID ${permissionId} not found`);
      }

      await this.roleRepository.removePermission(roleId, permissionId);

      this.loggingService.log('Permission removed from role successfully', LoggingHelper.logParams({
        roleId,
        roleName: role.name,
        permissionId,
        permissionName: permission.name,
        removedBy,
      }));
    } catch (error) {
      this.loggingService.error('Failed to remove permission from role', error, LoggingHelper.logParams({
        roleId,
        permissionId,
        removedBy,
      }));
      throw error;
    }
  }

  async createDefaultRoles(): Promise<RoleEntity[]> {
    try {
      const defaultRoles = RoleEntity.getDefaultRoles();
      const created: RoleEntity[] = [];

      for (const roleData of defaultRoles) {
        const existingRole = await this.roleRepository.findByName(roleData.name);
        if (!existingRole) {
          const role = new RoleEntity(
            '',
            roleData.name,
            roleData.name.toUpperCase().replace(/\s+/g, '_'), // Generate code from name
            roleData.description,
            roleData.category,
            true, // Active
            true, // Predefined
            new Date(),
            new Date(),
            'system', // createdBy
            [], // permissions array
            undefined, // programId
            undefined, // metadata
          );
          const createdRole = await this.roleRepository.create(role);
          created.push(createdRole);
        }
      }

      if (created.length > 0) {
        this.loggingService.log('Default roles created successfully', LoggingHelper.logParams({
          roles: created.map(r => r.name).join(', '),
        }));
      }

      return created;
    } catch (error) {
      this.loggingService.error('Failed to create default roles', error);
      throw error;
    }
  }

  async getRolePermissions(roleId: string): Promise<PermissionEntity[]> {
    try {
      const role = await this.roleRepository.findByIdWithPermissions(roleId);
      if (!role) {
        throw new NotFoundException(`Role with ID ${roleId} not found`);
      }

      return role.getPermissions();
    } catch (error) {
      this.loggingService.error('Failed to get role permissions', error, LoggingHelper.logParams({
        roleId,
      }));
      throw error;
    }
  }
}
