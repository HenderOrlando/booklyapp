/**
 * Resource Equivalence Entity
 * Represents equivalence relationships between resources for reassignment purposes
 */

export interface ResourceEquivalenceProps {
  id: string;
  programId: string;
  
  // Resource relationship
  primaryResourceId: string;
  equivalentResourceId: string;
  
  // Equivalence configuration
  equivalenceType: EquivalenceType;
  capacityTolerance: number; // Percentage tolerance for capacity differences
  priorityScore: number; // Higher score = better equivalence
  
  // Status and metadata
  isActive: boolean;
  isAutoGenerated: boolean; // true if generated by algorithm, false if manual
  notes?: string;
  
  // Timestamps
  createdAt: Date;
  updatedAt: Date;
}

export enum EquivalenceType {
  EXACT_MATCH = 'EXACT_MATCH', // Same type and similar capacity
  TYPE_MATCH = 'TYPE_MATCH', // Same type, different capacity within tolerance
  FUNCTIONAL_MATCH = 'FUNCTIONAL_MATCH', // Different type but similar functionality
  MANUAL_OVERRIDE = 'MANUAL_OVERRIDE' // Manually defined equivalence
}

export class ResourceEquivalenceEntity {
  private constructor(private readonly props: ResourceEquivalenceProps) {}

  static create(props: Omit<ResourceEquivalenceProps, 'id' | 'createdAt' | 'updatedAt'>): ResourceEquivalenceEntity {
    const now = new Date();
    return new ResourceEquivalenceEntity({
      ...props,
      id: '', // Will be set by repository
      createdAt: now,
      updatedAt: now,
      isActive: props.isActive !== undefined ? props.isActive : true,
      isAutoGenerated: props.isAutoGenerated !== undefined ? props.isAutoGenerated : false,
      capacityTolerance: props.capacityTolerance || 5, // Default 5% tolerance
      priorityScore: props.priorityScore || 50 // Default medium priority
    });
  }

  static fromPersistence(props: ResourceEquivalenceProps): ResourceEquivalenceEntity {
    return new ResourceEquivalenceEntity(props);
  }

  // Getters
  get id(): string { return this.props.id; }
  get programId(): string { return this.props.programId; }
  get primaryResourceId(): string { return this.props.primaryResourceId; }
  get equivalentResourceId(): string { return this.props.equivalentResourceId; }
  get equivalenceType(): EquivalenceType { return this.props.equivalenceType; }
  get capacityTolerance(): number { return this.props.capacityTolerance; }
  get priorityScore(): number { return this.props.priorityScore; }
  get isActive(): boolean { return this.props.isActive; }
  get isAutoGenerated(): boolean { return this.props.isAutoGenerated; }
  get notes(): string | undefined { return this.props.notes; }
  get createdAt(): Date { return this.props.createdAt; }
  get updatedAt(): Date { return this.props.updatedAt; }

  // Business logic methods

  /**
   * Validates if the resource equivalence is valid
   */
  validate(): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!this.props.programId) {
      errors.push('Program ID is required');
    }

    if (!this.props.primaryResourceId) {
      errors.push('Primary resource ID is required');
    }

    if (!this.props.equivalentResourceId) {
      errors.push('Equivalent resource ID is required');
    }

    if (this.props.primaryResourceId === this.props.equivalentResourceId) {
      errors.push('Primary and equivalent resources cannot be the same');
    }

    if (this.props.capacityTolerance < 0 || this.props.capacityTolerance > 100) {
      errors.push('Capacity tolerance must be between 0 and 100 percent');
    }

    if (this.props.priorityScore < 0 || this.props.priorityScore > 100) {
      errors.push('Priority score must be between 0 and 100');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Updates the equivalence configuration
   */
  update(updates: Partial<Pick<ResourceEquivalenceProps, 'equivalenceType' | 'capacityTolerance' | 'priorityScore' | 'isActive' | 'notes'>>): void {
    if (updates.equivalenceType !== undefined) {
      this.props.equivalenceType = updates.equivalenceType;
    }

    if (updates.capacityTolerance !== undefined) {
      if (updates.capacityTolerance < 0 || updates.capacityTolerance > 100) {
        throw new Error('Capacity tolerance must be between 0 and 100 percent');
      }
      this.props.capacityTolerance = updates.capacityTolerance;
    }

    if (updates.priorityScore !== undefined) {
      if (updates.priorityScore < 0 || updates.priorityScore > 100) {
        throw new Error('Priority score must be between 0 and 100');
      }
      this.props.priorityScore = updates.priorityScore;
    }

    if (updates.isActive !== undefined) {
      this.props.isActive = updates.isActive;
    }

    if (updates.notes !== undefined) {
      this.props.notes = updates.notes;
    }

    this.props.updatedAt = new Date();
  }

  /**
   * Activates the equivalence
   */
  activate(): void {
    this.props.isActive = true;
    this.props.updatedAt = new Date();
  }

  /**
   * Deactivates the equivalence
   */
  deactivate(): void {
    this.props.isActive = false;
    this.props.updatedAt = new Date();
  }

  /**
   * Adds or updates notes
   */
  updateNotes(notes: string): void {
    this.props.notes = notes;
    this.props.updatedAt = new Date();
  }

  /**
   * Checks if this is a bidirectional equivalence
   */
  isBidirectional(): boolean {
    // Most equivalences are bidirectional except for manual overrides with specific constraints
    return this.props.equivalenceType !== EquivalenceType.MANUAL_OVERRIDE;
  }

  /**
   * Checks if this equivalence was manually created
   */
  isManual(): boolean {
    return !this.props.isAutoGenerated;
  }

  /**
   * Checks if this equivalence was auto-generated
   */
  isAutomatic(): boolean {
    return this.props.isAutoGenerated;
  }

  /**
   * Gets the quality level of the equivalence
   */
  getQualityLevel(): 'EXCELLENT' | 'GOOD' | 'FAIR' | 'POOR' {
    if (this.props.equivalenceType === EquivalenceType.EXACT_MATCH && this.props.priorityScore >= 90) {
      return 'EXCELLENT';
    }
    
    if (this.props.priorityScore >= 75) {
      return 'GOOD';
    }
    
    if (this.props.priorityScore >= 50) {
      return 'FAIR';
    }
    
    return 'POOR';
  }

  /**
   * Gets the color code for UI representation
   */
  getColorCode(): string {
    switch (this.getQualityLevel()) {
      case 'EXCELLENT': return '#28a745'; // Green
      case 'GOOD': return '#17a2b8'; // Blue
      case 'FAIR': return '#ffc107'; // Yellow
      case 'POOR': return '#fd7e14'; // Orange
      default: return '#6c757d'; // Gray
    }
  }

  /**
   * Gets the equivalence type description
   */
  getEquivalenceTypeDescription(): string {
    const descriptions = {
      [EquivalenceType.EXACT_MATCH]: 'Exact match (same type and capacity)',
      [EquivalenceType.TYPE_MATCH]: 'Type match (same type, different capacity)',
      [EquivalenceType.FUNCTIONAL_MATCH]: 'Functional match (similar functionality)',
      [EquivalenceType.MANUAL_OVERRIDE]: 'Manual override (custom equivalence)'
    };

    return descriptions[this.props.equivalenceType] || 'Unknown equivalence type';
  }

  /**
   * Calculates compatibility score for a capacity difference
   */
  calculateCompatibilityScore(primaryCapacity: number, equivalentCapacity: number): number {
    if (primaryCapacity <= 0 || equivalentCapacity <= 0) {
      return 0;
    }

    const capacityDifference = Math.abs(primaryCapacity - equivalentCapacity);
    const maxCapacity = Math.max(primaryCapacity, equivalentCapacity);
    const capacityDifferencePercent = (capacityDifference / maxCapacity) * 100;

    if (capacityDifferencePercent <= this.props.capacityTolerance) {
      // Within tolerance, score based on how close they are
      const proximityScore = 100 - (capacityDifferencePercent / this.props.capacityTolerance) * 20;
      return Math.max(80, proximityScore); // Minimum 80 if within tolerance
    }

    // Outside tolerance, lower score
    const penaltyScore = Math.max(0, 80 - (capacityDifferencePercent - this.props.capacityTolerance) * 2);
    return penaltyScore;
  }

  /**
   * Checks if the equivalence is suitable for a given capacity requirement
   */
  isSuitableForCapacity(primaryCapacity: number, equivalentCapacity: number): boolean {
    if (this.props.equivalenceType === EquivalenceType.MANUAL_OVERRIDE) {
      return true; // Manual overrides are always considered suitable
    }

    const compatibilityScore = this.calculateCompatibilityScore(primaryCapacity, equivalentCapacity);
    return compatibilityScore >= 50; // Minimum 50% compatibility
  }

  /**
   * Gets the recommendation strength
   */
  getRecommendationStrength(): 'HIGHLY_RECOMMENDED' | 'RECOMMENDED' | 'ACCEPTABLE' | 'NOT_RECOMMENDED' {
    const quality = this.getQualityLevel();
    
    if (quality === 'EXCELLENT') {
      return 'HIGHLY_RECOMMENDED';
    }
    
    if (quality === 'GOOD') {
      return 'RECOMMENDED';
    }
    
    if (quality === 'FAIR') {
      return 'ACCEPTABLE';
    }
    
    return 'NOT_RECOMMENDED';
  }

  /**
   * Creates an exact match equivalence
   */
  static createExactMatch(
    programId: string,
    primaryResourceId: string,
    equivalentResourceId: string,
    isAutoGenerated: boolean = true
  ): ResourceEquivalenceEntity {
    return ResourceEquivalenceEntity.create({
      programId,
      primaryResourceId,
      equivalentResourceId,
      equivalenceType: EquivalenceType.EXACT_MATCH,
      capacityTolerance: 5,
      priorityScore: 95,
      isActive: true,
      isAutoGenerated
    });
  }

  /**
   * Creates a type match equivalence
   */
  static createTypeMatch(
    programId: string,
    primaryResourceId: string,
    equivalentResourceId: string,
    capacityTolerance: number = 10,
    isAutoGenerated: boolean = true
  ): ResourceEquivalenceEntity {
    return ResourceEquivalenceEntity.create({
      programId,
      primaryResourceId,
      equivalentResourceId,
      equivalenceType: EquivalenceType.TYPE_MATCH,
      capacityTolerance,
      priorityScore: 80,
      isActive: true,
      isAutoGenerated
    });
  }

  /**
   * Creates a functional match equivalence
   */
  static createFunctionalMatch(
    programId: string,
    primaryResourceId: string,
    equivalentResourceId: string,
    priorityScore: number = 60,
    isAutoGenerated: boolean = true
  ): ResourceEquivalenceEntity {
    return ResourceEquivalenceEntity.create({
      programId,
      primaryResourceId,
      equivalentResourceId,
      equivalenceType: EquivalenceType.FUNCTIONAL_MATCH,
      capacityTolerance: 20,
      priorityScore,
      isActive: true,
      isAutoGenerated
    });
  }

  /**
   * Creates a manual override equivalence
   */
  static createManualOverride(
    programId: string,
    primaryResourceId: string,
    equivalentResourceId: string,
    priorityScore: number = 70,
    notes?: string
  ): ResourceEquivalenceEntity {
    return ResourceEquivalenceEntity.create({
      programId,
      primaryResourceId,
      equivalentResourceId,
      equivalenceType: EquivalenceType.MANUAL_OVERRIDE,
      capacityTolerance: 50, // More lenient for manual overrides
      priorityScore,
      isActive: true,
      isAutoGenerated: false,
      notes
    });
  }

  // Conversion methods
  toPersistence(): ResourceEquivalenceProps {
    return { ...this.props };
  }

  toJSON() {
    return {
      id: this.props.id,
      programId: this.props.programId,
      primaryResourceId: this.props.primaryResourceId,
      equivalentResourceId: this.props.equivalentResourceId,
      equivalenceType: this.props.equivalenceType,
      capacityTolerance: this.props.capacityTolerance,
      priorityScore: this.props.priorityScore,
      isActive: this.props.isActive,
      isAutoGenerated: this.props.isAutoGenerated,
      notes: this.props.notes,
      createdAt: this.props.createdAt,
      updatedAt: this.props.updatedAt,
      qualityLevel: this.getQualityLevel(),
      colorCode: this.getColorCode(),
      equivalenceTypeDescription: this.getEquivalenceTypeDescription(),
      recommendationStrength: this.getRecommendationStrength(),
      isBidirectional: this.isBidirectional(),
      isManual: this.isManual(),
      isAutomatic: this.isAutomatic()
    };
  }
}
