import { ResourceEquivalenceEntity, EquivalenceType } from '../entities/resource-equivalence.entity';

/**
 * Resource Equivalence Repository Interface - Domain Layer
 * Defines the contract for resource equivalence data access
 */
export interface ResourceEquivalenceRepository {
  /**
   * Create a new resource equivalence
   */
  create(data: {
    programId: string;
    primaryResourceId: string;
    equivalentResourceId: string;
    equivalenceType: EquivalenceType;
    capacityTolerance: number;
    priorityScore: number;
    isActive: boolean;
    isAutoGenerated: boolean;
    notes?: string;
  }): Promise<ResourceEquivalenceEntity>;

  /**
   * Create multiple equivalences at once
   */
  createMany(
    equivalences: Array<{
      programId: string;
      primaryResourceId: string;
      equivalentResourceId: string;
      equivalenceType: EquivalenceType;
      capacityTolerance: number;
      priorityScore: number;
      isActive: boolean;
      isAutoGenerated: boolean;
      notes?: string;
    }>
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalence by ID
   */
  findById(id: string): Promise<ResourceEquivalenceEntity | null>;

  /**
   * Find all equivalences for a program
   */
  findByProgramId(programId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences for a primary resource
   */
  findByPrimaryResourceId(primaryResourceId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences for an equivalent resource
   */
  findByEquivalentResourceId(equivalentResourceId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find all equivalences involving a resource (as primary or equivalent)
   */
  findByResourceId(resourceId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences between two specific resources
   */
  findBetweenResources(
    resourceId1: string,
    resourceId2: string
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences by type
   */
  findByEquivalenceType(equivalenceType: EquivalenceType): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find active equivalences
   */
  findActiveEquivalences(): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find active equivalences for a program
   */
  findActiveByProgramId(programId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find active equivalences for a resource
   */
  findActiveByResourceId(resourceId: string): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find inactive equivalences
   */
  findInactiveEquivalences(): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find auto-generated equivalences
   */
  findAutoGeneratedEquivalences(): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find manual equivalences
   */
  findManualEquivalences(): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences by priority score range
   */
  findByPriorityScoreRange(
    minScore: number,
    maxScore: number
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find high-quality equivalences
   */
  findHighQualityEquivalences(threshold: number): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalences by capacity tolerance range
   */
  findByCapacityToleranceRange(
    minTolerance: number,
    maxTolerance: number
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find equivalent resources for a given resource
   */
  findEquivalentResources(
    primaryResourceId: string,
    programId: string,
    includeInactive?: boolean
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find best equivalent resources (highest priority score)
   */
  findBestEquivalentResources(
    primaryResourceId: string,
    programId: string,
    limit?: number
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Update equivalence
   */
  update(id: string, updates: Partial<ResourceEquivalenceEntity>): Promise<ResourceEquivalenceEntity>;

  /**
   * Update multiple equivalences
   */
  updateMany(
    equivalenceIds: string[],
    updates: Partial<ResourceEquivalenceEntity>
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Delete equivalence
   */
  delete(id: string): Promise<void>;

  /**
   * Delete all equivalences for a program
   */
  deleteByProgramId(programId: string): Promise<void>;

  /**
   * Delete all equivalences for a resource
   */
  deleteByResourceId(resourceId: string): Promise<void>;

  /**
   * Delete equivalences between two resources
   */
  deleteBetweenResources(resourceId1: string, resourceId2: string): Promise<void>;

  /**
   * Count equivalences by program
   */
  countByProgramId(programId: string): Promise<number>;

  /**
   * Count active equivalences
   */
  countActiveEquivalences(): Promise<number>;

  /**
   * Count equivalences by type
   */
  countByEquivalenceType(equivalenceType: EquivalenceType): Promise<number>;

  /**
   * Activate equivalence
   */
  activateEquivalence(id: string): Promise<ResourceEquivalenceEntity>;

  /**
   * Deactivate equivalence
   */
  deactivateEquivalence(id: string): Promise<ResourceEquivalenceEntity>;

  /**
   * Bulk activate equivalences
   */
  bulkActivateEquivalences(equivalenceIds: string[]): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Bulk deactivate equivalences
   */
  bulkDeactivateEquivalences(equivalenceIds: string[]): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Create bidirectional equivalence
   */
  createBidirectionalEquivalence(data: {
    programId: string;
    resourceId1: string;
    resourceId2: string;
    equivalenceType: EquivalenceType;
    capacityTolerance: number;
    priorityScore: number;
    isAutoGenerated: boolean;
    notes?: string;
  }): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Find duplicate equivalences
   */
  findDuplicateEquivalences(): Promise<Array<{
    primaryResourceId: string;
    equivalentResourceId: string;
    duplicates: ResourceEquivalenceEntity[];
  }>>;

  /**
   * Find orphaned equivalences (resources that no longer exist)
   */
  findOrphanedEquivalences(): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Validate equivalence configuration
   */
  validateEquivalenceConfiguration(data: {
    programId: string;
    primaryResourceId: string;
    equivalentResourceId: string;
    equivalenceType: EquivalenceType;
    capacityTolerance: number;
    priorityScore: number;
  }): Promise<{
    isValid: boolean;
    errors: string[];
    warnings: string[];
    existingEquivalences: ResourceEquivalenceEntity[];
  }>;

  /**
   * Generate automatic equivalences based on resource similarity
   */
  generateAutomaticEquivalences(
    programId: string,
    similarityThreshold: number
  ): Promise<ResourceEquivalenceEntity[]>;

  /**
   * Get equivalence statistics
   */
  getEquivalenceStats(programId?: string): Promise<{
    totalEquivalences: number;
    activeEquivalences: number;
    inactiveEquivalences: number;
    autoGeneratedEquivalences: number;
    manualEquivalences: number;
    equivalencesByType: Record<EquivalenceType, number>;
    equivalencesByQuality: {
      excellent: number;
      good: number;
      fair: number;
      poor: number;
    };
    averagePriorityScore: number;
    averageCapacityTolerance: number;
    resourcesWithEquivalences: number;
    resourcesWithoutEquivalences: number;
  }>;

  /**
   * Find resources with no equivalences
   */
  findResourcesWithoutEquivalences(programId: string): Promise<string[]>;

  /**
   * Find most connected resources (resources with many equivalences)
   */
  findMostConnectedResources(limit?: number): Promise<Array<{
    resourceId: string;
    equivalenceCount: number;
    averagePriorityScore: number;
  }>>;

  /**
   * Get equivalence network for a resource
   */
  getEquivalenceNetwork(resourceId: string, maxDepth: number): Promise<{
    resourceId: string;
    directEquivalences: ResourceEquivalenceEntity[];
    indirectEquivalences: Array<{
      equivalence: ResourceEquivalenceEntity;
      path: string[];
      depth: number;
    }>;
    networkSize: number;
  }>;

  /**
   * Find best replacement for a resource
   */
  findBestReplacement(
    originalResourceId: string,
    programId: string,
    requiredCapacity?: number,
    preferredFeatures?: string[]
  ): Promise<{
    bestReplacement: ResourceEquivalenceEntity | null;
    alternatives: ResourceEquivalenceEntity[];
    reasoning: string;
  }>;
}
