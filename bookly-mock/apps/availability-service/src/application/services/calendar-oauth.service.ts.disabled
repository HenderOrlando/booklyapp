import { ConfidentialClientApplication } from "@azure/msal-node";
import { Injectable, Logger, UnauthorizedException } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import * as crypto from "crypto";
import { google } from "googleapis";
import { OAuthProvider } from "../../../../../libs/oauth/src";

/**
 * Interfaz para tokens OAuth
 */
export interface OAuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresAt: Date;
  scope?: string;
}

/**
 * Interfaz para información de usuario
 */
export interface OAuthUserInfo {
  id: string;
  email: string;
  name?: string;
}

/**
 * Servicio para gestión de OAuth con proveedores de calendario
 *
 * @deprecated Este servicio ha sido reemplazado por CalendarIntegrationService
 * que utiliza @libs/oauth. Este archivo se mantendrá temporalmente para
 * compatibilidad pero será eliminado en futuras versiones.
 *
 * @see CalendarIntegrationService para la implementación actual
 */
@Injectable()
export class CalendarOAuthService {
  private readonly logger = new Logger(CalendarOAuthService.name);
  private readonly googleOAuth2Client: any;
  private readonly msalClient: ConfidentialClientApplication | null = null;

  constructor(private readonly configService: ConfigService) {
    // Configurar Google OAuth
    const googleClientId = this.configService.get<string>("GOOGLE_CLIENT_ID");
    const googleClientSecret = this.configService.get<string>(
      "GOOGLE_CLIENT_SECRET"
    );
    const googleRedirectUri = this.configService.get<string>(
      "GOOGLE_REDIRECT_URI"
    );

    if (googleClientId && googleClientSecret) {
      this.googleOAuth2Client = new google.auth.OAuth2(
        googleClientId,
        googleClientSecret,
        googleRedirectUri
      );
    } else {
      this.logger.warn("Google OAuth credentials not configured");
    }

    // Configurar Microsoft OAuth
    const msClientId = this.configService.get<string>("MICROSOFT_CLIENT_ID");
    const msClientSecret = this.configService.get<string>(
      "MICROSOFT_CLIENT_SECRET"
    );
    const msRedirectUri = this.configService.get<string>(
      "MICROSOFT_REDIRECT_URI"
    );

    if (msClientId && msClientSecret) {
      this.msalClient = new ConfidentialClientApplication({
        auth: {
          clientId: msClientId,
          authority: "https://login.microsoftonline.com/common",
          clientSecret: msClientSecret,
        },
      });
    } else {
      this.logger.warn("Microsoft OAuth credentials not configured");
    }
  }

  /**
   * Generar URL de autorización OAuth
   */
  async getAuthorizationUrl(
    provider: OAuthProvider,
    redirectUri: string
  ): Promise<{ url: string; state: string }> {
    const state = this.generateState();

    switch (provider) {
      case OAuthProvider.GOOGLE:
        return this.getGoogleAuthUrl(state, redirectUri);
      case OAuthProvider.MICROSOFT:
        return this.getOutlookAuthUrl(state, redirectUri);
      default:
        throw new UnauthorizedException(`Provider ${provider} not supported`);
    }
  }

  /**
   * Generar URL de autorización de Google
   */
  private getGoogleAuthUrl(
    state: string,
    redirectUri: string
  ): { url: string; state: string } {
    if (!this.googleOAuth2Client) {
      throw new UnauthorizedException("Google OAuth not configured");
    }

    this.googleOAuth2Client.redirectUri = redirectUri;

    const url = this.googleOAuth2Client.generateAuthUrl({
      access_type: "offline",
      scope: [
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.events",
        "https://www.googleapis.com/auth/userinfo.email",
        "https://www.googleapis.com/auth/userinfo.profile",
      ],
      state,
      prompt: "consent", // Forzar obtención de refresh token
    });

    return { url, state };
  }

  /**
   * Generar URL de autorización de Outlook
   */
  private getOutlookAuthUrl(
    state: string,
    redirectUri: string
  ): { url: string; state: string } {
    if (!this.msalClient) {
      throw new UnauthorizedException("Microsoft OAuth not configured");
    }

    const url =
      `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?` +
      `client_id=${this.configService.get("MICROSOFT_CLIENT_ID")}&` +
      `response_type=code&` +
      `redirect_uri=${encodeURIComponent(redirectUri)}&` +
      `response_mode=query&` +
      `scope=${encodeURIComponent("offline_access Calendars.ReadWrite User.Read")}&` +
      `state=${state}`;

    return { url, state };
  }

  /**
   * Intercambiar código de autorización por tokens
   */
  async exchangeCodeForTokens(
    provider: OAuthProvider,
    code: string,
    redirectUri: string
  ): Promise<OAuthTokens> {
    switch (provider) {
      case OAuthProvider.GOOGLE:
        return this.exchangeGoogleCode(code, redirectUri);
      case OAuthProvider.MICROSOFT:
        return this.exchangeOutlookCode(code, redirectUri);
      default:
        throw new UnauthorizedException(`Provider ${provider} not supported`);
    }
  }

  /**
   * Intercambiar código de Google
   */
  private async exchangeGoogleCode(
    code: string,
    redirectUri: string
  ): Promise<OAuthTokens> {
    try {
      this.googleOAuth2Client.redirectUri = redirectUri;

      const { tokens } = await this.googleOAuth2Client.getToken(code);

      if (!tokens.refresh_token) {
        throw new UnauthorizedException(
          "No refresh token received. User must re-authorize."
        );
      }

      return {
        accessToken: tokens.access_token!,
        refreshToken: tokens.refresh_token!,
        expiresAt: new Date(tokens.expiry_date!),
        scope: tokens.scope,
      };
    } catch (error) {
      this.logger.error(`Error exchanging Google code: ${error.message}`);
      throw new UnauthorizedException("Failed to exchange authorization code");
    }
  }

  /**
   * Intercambiar código de Outlook
   */
  private async exchangeOutlookCode(
    code: string,
    redirectUri: string
  ): Promise<OAuthTokens> {
    try {
      const tokenRequest = {
        code,
        scopes: ["offline_access", "Calendars.ReadWrite", "User.Read"],
        redirectUri,
      };

      const response = await this.msalClient!.acquireTokenByCode(tokenRequest);

      return {
        accessToken: response.accessToken,
        refreshToken: "", // MSAL maneja refresh tokens internamente
        expiresAt: new Date(response.expiresOn!),
        scope: response.scopes?.join(" ") || "",
      };
    } catch (error) {
      this.logger.error(`Error exchanging Outlook code: ${error.message}`);
      throw new UnauthorizedException("Failed to exchange authorization code");
    }
  }

  /**
   * Refrescar token de acceso
   */
  async refreshAccessToken(
    provider: OAuthProvider,
    refreshToken: string
  ): Promise<OAuthTokens> {
    switch (provider) {
      case OAuthProvider.GOOGLE:
        return this.refreshGoogleToken(refreshToken);
      case OAuthProvider.MICROSOFT:
        return this.refreshOutlookToken(refreshToken);
      default:
        throw new UnauthorizedException(`Provider ${provider} not supported`);
    }
  }

  /**
   * Refrescar token de Google
   */
  private async refreshGoogleToken(refreshToken: string): Promise<OAuthTokens> {
    try {
      this.googleOAuth2Client.setCredentials({
        refresh_token: refreshToken,
      });

      const { credentials } =
        await this.googleOAuth2Client.refreshAccessToken();

      return {
        accessToken: credentials.access_token!,
        refreshToken: credentials.refresh_token || refreshToken,
        expiresAt: new Date(credentials.expiry_date!),
        scope: credentials.scope,
      };
    } catch (error) {
      this.logger.error(`Error refreshing Google token: ${error.message}`);
      throw new UnauthorizedException("Failed to refresh access token");
    }
  }

  /**
   * Refrescar token de Outlook
   */
  private async refreshOutlookToken(
    refreshToken: string
  ): Promise<OAuthTokens> {
    try {
      const response = await this.msalClient!.acquireTokenSilent({
        scopes: ["https://graph.microsoft.com/.default"],
        account: null as any,
      });

      if (response) {
        return {
          accessToken: response.accessToken,
          refreshToken: refreshToken, // Mantener el refresh token original
          expiresAt: new Date(response.expiresOn!),
          scope: response.scopes?.join(" ") || "",
        };
      } else {
        throw new UnauthorizedException("Failed to refresh access token");
      }
    } catch (error) {
      this.logger.error(`Error refreshing Outlook token: ${error.message}`);
      throw new UnauthorizedException("Failed to refresh access token");
    }
  }

  /**
   * Obtener información del usuario
   */
  async getUserInfo(
    provider: OAuthProvider,
    accessToken: string
  ): Promise<OAuthUserInfo> {
    switch (provider) {
      case OAuthProvider.GOOGLE:
        return this.getGoogleUserInfo(accessToken);
      case OAuthProvider.MICROSOFT:
        return this.getOutlookUserInfo(accessToken);
      default:
        throw new UnauthorizedException(`Provider ${provider} not supported`);
    }
  }

  /**
   * Obtener información de usuario de Google
   */
  private async getGoogleUserInfo(accessToken: string): Promise<OAuthUserInfo> {
    try {
      this.googleOAuth2Client.setCredentials({
        access_token: accessToken,
      });

      const oauth2 = google.oauth2({
        auth: this.googleOAuth2Client,
        version: "v2",
      });

      const { data } = await oauth2.userinfo.get();

      return {
        id: data.id!,
        email: data.email!,
        name: data.name ?? undefined,
      };
    } catch (error) {
      this.logger.error(`Error getting Google user info: ${error.message}`);
      throw new UnauthorizedException("Failed to get user information");
    }
  }

  /**
   * Obtener información de usuario de Outlook
   */
  private async getOutlookUserInfo(
    accessToken: string
  ): Promise<OAuthUserInfo> {
    try {
      const fetch = (await import("node-fetch")).default;
      const response = await fetch("https://graph.microsoft.com/v1.0/me", {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });

      const data: any = await response.json();

      return {
        id: data.id,
        email: data.userPrincipalName || data.mail,
        name: data.displayName,
      };
    } catch (error) {
      this.logger.error(`Error getting Outlook user info: ${error.message}`);
      throw new UnauthorizedException("Failed to get user information");
    }
  }

  /**
   * Generar state aleatorio para CSRF protection
   */
  private generateState(): string {
    return crypto.randomBytes(32).toString("hex");
  }

  /**
   * Encriptar token
   */
  encryptToken(token: string): string {
    const algorithm = "aes-256-cbc";
    const key = Buffer.from(
      this.configService.get<string>("ENCRYPTION_KEY") ||
        "default-key-32-chars-required!!",
      "utf8"
    ).slice(0, 32);
    const iv = crypto.randomBytes(16);

    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(token, "utf8", "hex");
    encrypted += cipher.final("hex");

    return `${iv.toString("hex")}:${encrypted}`;
  }

  /**
   * Desencriptar token
   */
  decryptToken(encryptedToken: string): string {
    const algorithm = "aes-256-cbc";
    const key = Buffer.from(
      this.configService.get<string>("ENCRYPTION_KEY") ||
        "default-key-32-chars-required!!",
      "utf8"
    ).slice(0, 32);

    const [ivHex, encrypted] = encryptedToken.split(":");
    const iv = Buffer.from(ivHex, "hex");

    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted;
  }
}
